트랜잭션과 잠금에서 추가적인 내용을 알아보자.

## 전파행위 옵션
A 트랜잭션, B 트랜잭션이 있다고 보자.

A 트랜잭션을 진행하는 도중 다른 트랜잭션(B)을 진행하기도 한다.

그 때의 A와 B는 다른 트랜잭션이라고 봐야 할까 같은 트랜잭션으로 봐야 할까? 에 대해 다루는 것이 전파행위 옵션이다.

> 즉, **트랜잭션 전파** : 현재 트랜잭션에서 다른 트랜잭션으로 이동할 때를 이야기한다.

- `REQUIRED` : **진행 중인 트랜잭션이 있으면** 현재 메소드를 **그 트랜잭션에서 실행**하되 그렇지 않은 경우 **(진행 중인 것이 없는 경우) 새 트랜잭션을 시작해서 실행**한다.

- `REQUIRED_NEW` : **항상 새 트랜잭션을 시작**해 메소드를 실행하고 진행중인 트랜잭션이 있으면 잠시 중단시킨다.
- `SUPPORTS` : **진행 중인 트랜잭션이 있으면 현재 메소드를 그 트랜잭션 내에서 실행**하되, 그렇지 않을 경우 **(진행 중인 트랜잭션이 없으면) 트랜잭션 없이 실행**한다.
- `NOT_SUPPORTED` : 트랜잭션 **없이 현재 메소드를 실행**하고 **진행 중인 트랜잭션이 있으면 잠시 중단**한다
- `MANDATORY` : 반드시 트랜잭션을 걸고 현재 메소드를 실행하되 진행 중인 트랜잭션이 있으면 예외를 던진다.
- `NEVER` : **반드시 트랜잭션 없이 현재 메소드를 실행하되 진행 중인 트랜잭션이 있으면 예외**를 던진다.
- `NESTED` : **진행중인 트랜잭션이 있으면 현재 메소드를 이 트랜잭션의 중첩 트랜잭션 내에서 실행**한다. 
  - 진행 중인 트랜잭션이 없으면 새 트랜잭션을 실행한다.
  - 배치 실행 도중 처리 할 업무가 100 만개라고 하면 10만개씩 끊어서 커밋하는 경우, 중간에 잘못 되어도 중첩 트랜잭션을 롤백하면 전체가 아닌 10만개만 롤백된다.
  - 세이브포인트를 이용하는 방식이다. 따라서 세이브포인트를 지원하지 않는 경우 사용 불가능하다.

---
## 격리 수준
[mysql의-격리-수준](https://velog.io/@jojehuni_9759/SQL-트랜잭션과-잠금#mysql의-격리-수준 )

여기서 같이 보면 괜찮을 것이다.

---
## 오염된 값
**오염된 값** : 하나의 트랜젝션이 데이터를 변경 후 잠시 기다리는 동안 다른 트랜젝션이 데이터를 읽게 되면, 격리레벨이 `READ_UNCOMMITTED`인 경우 아직 변경 후 커밋하지 않은 재고값을 그대로 읽게 된다

그러나 처음 트랜젝션이 데이터를 롤백하게 되면 다른 트랜젝션이 읽은 값은 더 이상 유효하지 않은 일시적인 값이 된다. 

이것을 오염된 값라고 한다.

---
## 재현 불가능한 값 읽기
재현 불가능한 값 읽기 : 처음 트랜젝션이 데이터를 수정하면 수정이 되고 아직 커밋되지 않은 로우에 수정 잠금을 걸어둔 상태에다. 

결국 다른 트랜젝션은 이 트랜젝션이 커밋 혹은 롤백 되고 수정잠금이 풀릴 때까지 기다렸다가 읽을 수 밖에 없게 된다. 

하지만 다른 로우에 대해서는 또 다른 트랜젝션이 데이터를 수정하고 커밋을 하게 되면 가장 처음 동작한 트랜젝션이 데이터를 커밋하고 다시 조회를 한 경우 처음 읽은 그 값이 아니게 된다. 

이것이 재현 불가능한 값이라고 한다.

---
## 허상 읽기
허상 읽기 : 처음 트랜젝션이 테이블에서 여러 로우를 읽은 후 이후 트랜젝션이 같은 테이블의 로우를 추가하는 경우 처음 트랜젝션이 같은 테이블을 다시 읽으면 자신이 처음 읽었을 때와 달리 새로 추가 된 로우가 있을 것이다. 

이것을 허상 읽기라고 한다. (재현 불가능한 값 읽기와 유사하지만 허상 읽기는 여러 로우가 추가되는 경우를 말한다.)
